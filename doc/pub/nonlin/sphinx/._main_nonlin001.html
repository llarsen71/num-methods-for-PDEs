
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Introduction of basic concepts</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="_static/sidebar.js"></script>
    <link rel="top" title="Solving nonlinear ODE and PDE problems" href="index.html" />
    <link rel="next" title="Systems of nonlinear algebraic equations" href="._main_nonlin002.html" />
    <link rel="prev" title="Solving nonlinear ODE and PDE problems" href="._main_nonlin000.html" /> 
  
       <style type="text/css">
         div.admonition {
           background-color: whiteSmoke;
           border: 1px solid #bababa;
         }
       </style>
      </head>
    
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="._main_nonlin002.html" title="Systems of nonlinear algebraic equations"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="._main_nonlin000.html" title="Solving nonlinear ODE and PDE problems"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Solving nonlinear ODE and PDE problems</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="introduction-of-basic-concepts">
<span id="nonlin-timediscrete-logistic"></span><h1>Introduction of basic concepts<a class="headerlink" href="#introduction-of-basic-concepts" title="Permalink to this headline">¶</a></h1>
<div class="section" id="linear-versus-nonlinear-equations">
<h2>Linear versus nonlinear equations<a class="headerlink" href="#linear-versus-nonlinear-equations" title="Permalink to this headline">¶</a></h2>
<div class="section" id="algebraic-equations">
<h3>Algebraic equations<a class="headerlink" href="#algebraic-equations" title="Permalink to this headline">¶</a></h3>
<p>A linear, scalar, algebraic equation in <span class="math">\(x\)</span> has the form</p>
<div class="math">
\[ax + b = 0,\]</div>
<p>for arbitrary real constants <span class="math">\(a\)</span> and <span class="math">\(b\)</span>. The unknown is a number <span class="math">\(x\)</span>.
All other algebraic equations, e.g., <span class="math">\(x^2 + ax + b = 0\)</span>, are nonlinear.
The typical feature in a nonlinear algebraic equation is that the unknown
appears in products with itself, like <span class="math">\(x^2\)</span> or <span class="math">\(e^x = 1 + x +\frac{1}{2} x^2 +
\frac{1}{3!}x^3 + \cdots\)</span>.</p>
<p>We know how to solve a linear algebraic equation, <span class="math">\(x=-b/a\)</span>, but there are
no general methods for finding the exact solutions of
nonlinear algebraic equations, except for very special cases (quadratic
equations are a primary example). A nonlinear algebraic equation
may have no solution, one solution, or many solutions. The tools for
solving nonlinear algebraic equations are <em>iterative methods</em>, where
we construct a series of linear equations, which we know how to solve,
and hope that the solutions of the linear equations converge to the
solution of the nonlinear equation we want to solve.
Typical methods for nonlinear algebraic equations are
Newton&#8217;s method, the Bisection method, and the Secant method.</p>
</div>
<div class="section" id="differential-equations">
<h3>Differential equations<a class="headerlink" href="#differential-equations" title="Permalink to this headline">¶</a></h3>
<p>The unknown in a differential equation is a function and not a number.
In a linear differential equation, all terms involving the unknown functions
are linear in the unknown functions or their derivatives. Linear here means that
the unknown function, or a derivative of it, is multiplied by a number or
a known function. All other differential equations are non-linear.</p>
<p>The easiest way to see if an equation is nonlinear, is to spot nonlinear terms
where the unknown functions or their derivatives are multiplied by
each other. For example, in</p>
<div class="math">
\[u^{\prime}(t) = -a(t)u(t) + b(t),\]</div>
<p>the terms involving the unknown function <span class="math">\(u\)</span> are linear: <span class="math">\(u^{\prime}\)</span> contains
the derivative of the unknown function multiplied by unity, and <span class="math">\(au\)</span> contains
the unknown function multiplied by a known function.
However,</p>
<div class="math">
\[u^{\prime}(t) = u(t)(1 - u(t)),\]</div>
<p>is nonlinear because of the term <span class="math">\(-u^2\)</span> where the unknown function is
multiplied by itself. Also</p>
<div class="math">
\[\frac{\partial u}{\partial t} + u\frac{\partial u}{\partial x} = 0,\]</div>
<p>is nonlinear because of the term <span class="math">\(uu_x\)</span> where the unknown
function appears in a product with itself or one if its derivatives.
(Note here that we use different notations for derivatives: <span class="math">\(u^{\prime}\)</span>
or <span class="math">\(du/dt\)</span> for a function <span class="math">\(u(t)\)</span> of one variable,
<span class="math">\(\frac{\partial u}{\partial t}\)</span> or <span class="math">\(u_t\)</span> for a function of more than one
variable.)</p>
<p>Another example of a nonlinear equation is</p>
<div class="math">
\[u^{\prime\prime} + \sin(u) =0,\]</div>
<p>because <span class="math">\(\sin(u)\)</span> contains products of <span class="math">\(u\)</span> if we expand the function in
a Taylor series:</p>
<div class="math">
\[\sin(u) = u - \frac{1}{3} u^3 + \ldots\]</div>
<div class="admonition-mathematical-proof-of-linearity admonition">
<p class="first admonition-title">Mathematical proof of linearity</p>
<p>To really prove mathematically that some differential equation
in an unknown <span class="math">\(u\)</span> is linear,
show for each term <span class="math">\(T(u)\)</span> that with <span class="math">\(u = au_1 + bu_2\)</span> for
constants <span class="math">\(a\)</span> and <span class="math">\(b\)</span>,</p>
<div class="math">
\[T(au_1 + bu_2) = aT(u_1) + bT(u_2){\thinspace .}\]</div>
<p>For example, the term <span class="math">\(T(u) = (\sin^2 t)u'(t)\)</span> is linear because</p>
<div class="math">
\[\begin{split}T(au_1 + bu_2) &amp;= (\sin^2 t)(au_1(t) + b u_2(t))'\\
&amp; = a(\sin^2 t)u_1'(t) + b(\sin^2 t)u_2'(t)\\
&amp; =aT(u_1) + bT(u_2){\thinspace .}\end{split}\]</div>
<p>However, <span class="math">\(T(u)=\sin u\)</span> is nonlinear because</p>
<div class="last math">
\[T(au_1 + bu_2) = \sin (au_1 + bu_2) \neq a\sin u_1 + b\sin u_2{\thinspace .}\]</div>
</div>
</div>
</div>
<div class="section" id="a-simple-model-problem">
<h2>A simple model problem<a class="headerlink" href="#a-simple-model-problem" title="Permalink to this headline">¶</a></h2>
<p>A series of forthcoming examples will explain how to tackle
nonlinear differential equations with various techniques.
We start with the (scaled) logistic equation as model problem:</p>
<div class="math" id="eq-nonlin-timediscrete-logistic-eq">
\[\tag{1}
u^{\prime}(t) = u(t)(1 - u(t)) {\thinspace .}\]</div>
<p>This is a nonlinear ordinary differential equation (ODE)
which will be solved by
different strategies in the following.
Depending on the chosen
time discretization of <a class="reference internal" href="#eq-nonlin-timediscrete-logistic-eq"><span>(1)</span></a>,
the mathematical problem to be solved at every time level will
either be a linear algebraic equation or a nonlinear
algebraic equation.
In the former case, the time discretization method transforms
the nonlinear ODE into linear subproblems at each time level, and
the solution is straightforward to find since linear algebraic equations
are easy to solve. However,
when the time discretization leads to nonlinear algebraic equations, we
cannot (except in very rare cases) solve these without turning to
approximate, iterative solution methods.</p>
<p>The next subsections introduce various methods
for solving nonlinear differential equations,
using <a class="reference internal" href="#eq-nonlin-timediscrete-logistic-eq"><span>(1)</span></a> as model. We shall go through
the following set cases:</p>
<blockquote>
<div><ul class="simple">
<li>explicit time discretization methods (with no need to
solve nonlinear algebraic equations)</li>
<li>implicit Backward Euler discretization, leading to nonlinear
algebraic equations solved by</li>
</ul>
<blockquote>
<div><ul class="simple">
<li>an exact analytical technique</li>
<li>Picard iteration based on manual linearization</li>
<li>a single Picard step</li>
<li>Newton&#8217;s method</li>
</ul>
</div></blockquote>
<ul class="simple">
<li>implicit Crank-Nicolson discretization and linearization
via a geometric mean formula</li>
</ul>
</div></blockquote>
<p>Thereafter, we compare the performance of the various approaches. Despite
the simplicity of <a class="reference internal" href="#eq-nonlin-timediscrete-logistic-eq"><span>(1)</span></a>, the conclusions
reveal typical features of the various methods in much more complicated
nonlinear PDE problems.</p>
</div>
<div class="section" id="linearization-by-explicit-time-discretization">
<span id="nonlin-timediscrete-logistic-fe"></span><h2>Linearization by explicit time discretization<a class="headerlink" href="#linearization-by-explicit-time-discretization" title="Permalink to this headline">¶</a></h2>
<p id="index-0">Time discretization methods are divided into explicit and implicit
methods. Explicit methods lead to a closed-form formula for
finding new values of the unknowns, while implicit methods give
a linear or nonlinear system of equations that couples (all) the
unknowns at a new time level. Here we shall demonstrate that
explicit methods constitute an efficient way to deal with nonlinear
differential equations.</p>
<p>The Forward Euler
method is an explicit method. When applied to
<a class="reference internal" href="#eq-nonlin-timediscrete-logistic-eq"><span>(1)</span></a>, sampled at <span class="math">\(t=t_n\)</span>, it results in</p>
<div class="math">
\[\frac{u^{n+1} - u^n}{\Delta t} = u^n(1 - u^n),\]</div>
<p>which is a <em>linear</em> algebraic
equation for the unknown value <span class="math">\(u^{n+1}\)</span> that we can easily solve:</p>
<div class="math">
\[u^{n+1} = u^n + \Delta t\,u^n(1 - u^n){\thinspace .}\]</div>
<p>The nonlinearity in the original equation poses in this case no difficulty
in the discrete algebraic equation.
Any other explicit scheme in time will also give only linear
algebraic equations
to solve. For example, a typical 2nd-order Runge-Kutta method
for <a class="reference internal" href="#eq-nonlin-timediscrete-logistic-eq"><span>(1)</span></a> leads to the following
formulas:</p>
<div class="math">
\[\begin{split}u^* &amp;= u^n + \Delta t u^n(1 - u^n),\\
u^{n+1} &amp;= u^n + \Delta t \frac{1}{2} \left(
u^n(1 - u^n) + u^*(1 - u^*))
\right){\thinspace .}\end{split}\]</div>
<p>The first step is linear in the unknown <span class="math">\(u^*\)</span>. Then <span class="math">\(u^*\)</span> is
known in the next step, which is linear in the unknown <span class="math">\(u^{n+1}\)</span> .</p>
</div>
<div class="section" id="exact-solution-of-nonlinear-algebraic-equations">
<span id="nonlin-timediscrete-logistic-roots"></span><h2>Exact solution of nonlinear algebraic equations<a class="headerlink" href="#exact-solution-of-nonlinear-algebraic-equations" title="Permalink to this headline">¶</a></h2>
<p>Switching to a Backward Euler scheme for
<a class="reference internal" href="#eq-nonlin-timediscrete-logistic-eq"><span>(1)</span></a>,</p>
<div class="math" id="eq-nonlin-timediscrete-logistic-eq-be">
\[\tag{2}
\frac{u^{n} - u^{n-1}}{\Delta t} = u^n(1 - u^n),\]</div>
<p>results in a nonlinear algebraic equation for the unknown value <span class="math">\(u^n\)</span>.
The equation is of quadratic type:</p>
<div class="math">
\[\Delta t (u^n)^2 + (1-\Delta t)u^n - u^{n-1} = 0,\]</div>
<p>and may be solved exactly by the well-known formula for such equations.
Before we do so, however, we will
introduce a shorter, and often cleaner, notation for
nonlinear algebraic equations at a given time level. The notation is
inspired by the natural notation (i.e., variable names) used in a
program, especially in more advanced partial differential equation
problems. The unknown in the algebraic equation is denoted by <span class="math">\(u\)</span>,
while <span class="math">\(u^{(1)}\)</span> is the value of the unknown at the previous time level
(in general, <span class="math">\(u^{(\ell)}\)</span> is the value of the unknown <span class="math">\(\ell\)</span> levels
back in time). The notation will be frequently used in later
sections. What is meant by <span class="math">\(u\)</span> should be evident from the context: <span class="math">\(u\)</span>
may be 1) the exact solution of the ODE/PDE problem,
2) the numerical approximation to the exact solution, or 3) the unknown
solution at a certain time level.</p>
<p>The quadratic equation for the unknown <span class="math">\(u^n\)</span> in
<a class="reference internal" href="#eq-nonlin-timediscrete-logistic-eq-be"><span>(2)</span></a> can, with the new
notation, be written</p>
<div class="math" id="eq-nonlin-timediscrete-logistic-eq-f">
\[\tag{3}
F(u) = \Delta t u^2 + (1-\Delta t)u - u^{(1)} = 0{\thinspace .}\]</div>
<p>The solution is readily found to be</p>
<div class="math" id="eq-nonlin-timediscrete-logistic-eq-roots">
\[\tag{4}
u = \frac{1}{2\Delta t}
    \left(-1+\Delta t \pm \sqrt{(1-\Delta t)^2 + 4\Delta t u^{(1)}}\right)
    {\thinspace .}\]</div>
<p>Now we encounter a fundamental challenge with nonlinear
algebraic equations:
the equation may have more than one solution. How do we pick the right
solution? This is in general a hard problem.
In the present simple case, however, we can analyze the roots mathematically
and provide an answer. The idea is to expand the roots
in a series in <span class="math">\(\Delta t\)</span> and truncate after the linear term since
the Backward Euler scheme will introduce an error proportional to
<span class="math">\(\Delta t\)</span> anyway. Using <code class="docutils literal"><span class="pre">sympy</span></code> we find the following Taylor series
expansions of the roots:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">sympy</span> <span class="kn">as</span> <span class="nn">sym</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dt</span><span class="p">,</span> <span class="n">u_1</span><span class="p">,</span> <span class="n">u</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s">&#39;dt u_1 u&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r1</span><span class="p">,</span> <span class="n">r2</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">dt</span><span class="o">*</span><span class="n">u</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">dt</span><span class="p">)</span><span class="o">*</span><span class="n">u</span> <span class="o">-</span> <span class="n">u_1</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>  <span class="c"># find roots</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r1</span>
<span class="go">(dt - sqrt(dt**2 + 4*dt*u_1 - 2*dt + 1) - 1)/(2*dt)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r2</span>
<span class="go">(dt + sqrt(dt**2 + 4*dt*u_1 - 2*dt + 1) - 1)/(2*dt)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">r1</span><span class="o">.</span><span class="n">series</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>    <span class="c"># 2 terms in dt, around dt=0</span>
<span class="go">-1/dt + 1 - u_1 + dt*(u_1**2 - u_1) + O(dt**2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">r2</span><span class="o">.</span><span class="n">series</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">u_1 + dt*(-u_1**2 + u_1) + O(dt**2)</span>
</pre></div>
</div>
<p>We see that the <code class="docutils literal"><span class="pre">r1</span></code> root, corresponding to
a minus sign in front of the square root in
<a class="reference internal" href="#eq-nonlin-timediscrete-logistic-eq-roots"><span>(4)</span></a>,
behaves as <span class="math">\(1/\Delta t\)</span> and will therefore
blow up as <span class="math">\(\Delta t\rightarrow 0\)</span>! Since we know that <span class="math">\(u\)</span> takes on
finite values, actually it is less than or equal to 1,
only the <code class="docutils literal"><span class="pre">r2</span></code> root is of relevance in this case: as <span class="math">\(\Delta t\rightarrow 0\)</span>,
<span class="math">\(u\rightarrow u^{(1)}\)</span>, which is the expected result.</p>
<p>For those who are not well experienced with approximating mathematical
formulas by series expansion, an alternative method of investigation
is simply to compute the limits of the two roots as <span class="math">\(\Delta t\rightarrow 0\)</span>
and see if a limit unreasonable:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">r1</span><span class="o">.</span><span class="n">limit</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="go">-oo</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">r2</span><span class="o">.</span><span class="n">limit</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="go">u_1</span>
</pre></div>
</div>
</div>
<div class="section" id="linearization">
<h2>Linearization<a class="headerlink" href="#linearization" title="Permalink to this headline">¶</a></h2>
<p>When the time integration of an ODE results in a nonlinear algebraic
equation, we must normally find its solution by defining a sequence
of linear equations and hope that the solutions of these linear equations
converge to the desired solution of the nonlinear algebraic equation.
Usually, this means solving the linear equation repeatedly in an
iterative fashion.
Alternatively, the nonlinear equation can sometimes be approximated by one
linear equation, and consequently there is no need for iteration.</p>
<p id="index-1">Constructing a linear equation from a nonlinear one requires
<em>linearization</em> of each nonlinear term. This can be done manually
as in Picard iteration, or fully algorithmically as in Newton&#8217;s method.
Examples will best illustrate how to linearize nonlinear problems.</p>
</div>
<div class="section" id="picard-iteration-1">
<span id="nonlin-timediscrete-logistic-picard"></span><h2>Picard iteration<a class="headerlink" href="#picard-iteration-1" title="Permalink to this headline">¶</a></h2>
<span class="target" id="index-2"></span><span class="target" id="index-3"></span><span class="target" id="index-4"></span><span class="target" id="index-5"></span><span class="target" id="index-6"></span><p id="index-7">Let us write <a class="reference internal" href="#eq-nonlin-timediscrete-logistic-eq-f"><span>(3)</span></a> in a
more compact form</p>
<div class="math">
\[F(u) = au^2 + bu + c = 0,\]</div>
<p>with <span class="math">\(a=\Delta t\)</span>, <span class="math">\(b=1-\Delta t\)</span>, and <span class="math">\(c=-u^{(1)}\)</span>.
Let <span class="math">\(u^{-}\)</span> be an available approximation of the unknown <span class="math">\(u\)</span>.
Then we can linearize the term <span class="math">\(u^2\)</span> simply by writing
<span class="math">\(u^{-}u\)</span>. The resulting equation, <span class="math">\(\hat F(u)=0\)</span>, is now linear
and hence easy to solve:</p>
<div class="math">
\[F(u)\approx\hat F(u) = au^{-}u + bu + c = 0{\thinspace .}\]</div>
<p>Since the equation <span class="math">\(\hat F=0\)</span> is only approximate, the solution <span class="math">\(u\)</span>
does not equal the exact solution <span class="math">\({u_{\small\mbox{e}}}\)</span> of the exact
equation <span class="math">\(F({u_{\small\mbox{e}}})=0\)</span>, but we can hope that <span class="math">\(u\)</span> is closer to
<span class="math">\({u_{\small\mbox{e}}}\)</span> than <span class="math">\(u^{-}\)</span> is, and hence it makes sense to repeat the
procedure, i.e., set <span class="math">\(u^{-}=u\)</span> and solve <span class="math">\(\hat F(u)=0\)</span> again.
There is no guarantee that <span class="math">\(u\)</span> is closer to <span class="math">\({u_{\small\mbox{e}}}\)</span> than <span class="math">\(u^{-}\)</span>,
but this approach has proven to be effective in a wide range of
applications.</p>
<p>The idea of turning a nonlinear equation into a linear one by
using an approximation <span class="math">\(u^{-}\)</span> of <span class="math">\(u\)</span> in nonlinear terms is
a widely used approach that goes under many names:
<em>fixed-point iteration</em>, the method of <em>successive substitutions</em>,
<em>nonlinear Richardson iteration</em>, and <em>Picard iteration</em>.
We will stick to the latter name.</p>
<p>Picard iteration for solving the nonlinear equation
arising from the Backward Euler discretization of the logistic
equation can be written as</p>
<div class="math">
\[u = -\frac{c}{au^{-} + b},\quad u^{-}\ \leftarrow\ u{\thinspace .}\]</div>
<p>The <span class="math">\(\leftarrow\)</span> symbols means assignment (we set <span class="math">\(u^{-}\)</span> equal to
the value of <span class="math">\(u\)</span>).
The iteration is started with the value of the unknown at the
previous time level: <span class="math">\(u^{-}=u^{(1)}\)</span>.</p>
<p>Some people prefer an explicit iteration counter as superscript
in the mathematical notation. Let <span class="math">\(u^k\)</span> be the computed approximation
to the solution in iteration <span class="math">\(k\)</span>. In iteration <span class="math">\(k+1\)</span> we want
to solve</p>
<div class="math">
\[au^k u^{k+1} + bu^{k+1} + c = 0\quad\Rightarrow\quad u^{k+1}
= -\frac{c}{au^k + b},\quad k=0,1,\ldots\]</div>
<p>Since we need to perform the iteration at every time level, the
time level counter is often also included (recall that <span class="math">\(c=-u^{n-1}\)</span>):</p>
<div class="math">
\[au^{n,k} u^{n,k+1} + bu^{n,k+1} - u^{n-1} = 0\quad\Rightarrow\quad u^{n,k+1}
= \frac{u^{n-1}}{au^{n,k} + b},\quad k=0,1,\ldots,\]</div>
<p>with the start value <span class="math">\(u^{n,0}=u^{n-1}\)</span> and the final converged value
<span class="math">\(u^{n}=u^{n,k}\)</span> for sufficiently large <span class="math">\(k\)</span>.</p>
<p>However, we will normally apply a mathematical notation in our
final formulas that is as close as possible to what we aim to write
in a computer code and then it becomes natural to use <span class="math">\(u\)</span> and <span class="math">\(u^{-}\)</span>
instead of <span class="math">\(u^{k+1}\)</span> and <span class="math">\(u^k\)</span> or <span class="math">\(u^{n,k+1}\)</span> and <span class="math">\(u^{n,k}\)</span>.</p>
<div class="section" id="stopping-criteria-1">
<span id="index-8"></span><h3>Stopping criteria<a class="headerlink" href="#stopping-criteria-1" title="Permalink to this headline">¶</a></h3>
<p>The iteration method can typically be terminated when the change
in the solution is smaller than a tolerance <span class="math">\(\epsilon_u\)</span>:</p>
<div class="math">
\[|u - u^{-}| \leq\epsilon_u,\]</div>
<p>or when the residual in the equation is sufficiently small (<span class="math">\(\epsilon_r\)</span>),</p>
<div class="math">
\[\begin{split}|F(u)|= |au^2+bu + c| &lt; \epsilon_r{\thinspace .}\end{split}\]</div>
</div>
<div class="section" id="a-single-picard-iteration">
<span id="index-9"></span><h3>A single Picard iteration<a class="headerlink" href="#a-single-picard-iteration" title="Permalink to this headline">¶</a></h3>
<p>Instead of iterating until a stopping criterion is fulfilled, one may
iterate a specific number of times. Just one Picard iteration is
popular as this corresponds to the intuitive idea of approximating
a nonlinear term like <span class="math">\((u^n)^2\)</span> by <span class="math">\(u^{n-1}u^n\)</span>. This follows
from the linearization <span class="math">\(u^{-}u^n\)</span> and the initial choice of
<span class="math">\(u^{-}=u^{n-1}\)</span> at time level <span class="math">\(t_n\)</span>. In other words, a single
Picard iteration corresponds to using the solution at
the previous time level to linearize
nonlinear terms. The resulting discretization
becomes (using proper values for <span class="math">\(a\)</span>, <span class="math">\(b\)</span>, and <span class="math">\(c\)</span>)</p>
<div class="math" id="eq-nonlin-timediscrete-logistic-be-picard-1it">
\[\tag{5}
\frac{u^{n} - u^{n-1}}{\Delta t} = u^n(1 - u^{n-1}),\]</div>
<p>which is a linear algebraic equation in the unknown <span class="math">\(u^n\)</span>, and
therefore we can easily solve for <span class="math">\(u^n\)</span>, and there is no need
for any alternative notation.</p>
<p>We shall later refer to the strategy of taking one Picard step, or
equivalently, linearizing terms with use of the solution at the
previous time step, as the <em>Picard1</em> method. It is a widely used
approach in science and technology, but with some limitations if
<span class="math">\(\Delta t\)</span> is not sufficiently small (as will be illustrated later).</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Equation <a class="reference internal" href="#eq-nonlin-timediscrete-logistic-be-picard-1it"><span>(5)</span></a> does not
correspond to a &#8220;pure&#8221; finite difference method where the equation
is sampled at a point and derivatives replaced by differences (because
the <span class="math">\(u^{n-1}\)</span> term on the right-hand side must then be <span class="math">\(u^n\)</span>). The
best interpretation of the scheme
<a class="reference internal" href="#eq-nonlin-timediscrete-logistic-be-picard-1it"><span>(5)</span></a> is a Backward Euler
difference combined with a single (perhaps insufficient) Picard
iteration at each time level, with the value at the previous time
level as start for the Picard iteration.</p>
</div>
</div>
</div>
<div class="section" id="linearization-by-a-geometric-mean">
<span id="nonlin-timediscrete-logistic-geometric-mean"></span><h2>Linearization by a geometric mean<a class="headerlink" href="#linearization-by-a-geometric-mean" title="Permalink to this headline">¶</a></h2>
<p>We consider now a Crank-Nicolson discretization of
<a class="reference internal" href="#eq-nonlin-timediscrete-logistic-eq"><span>(1)</span></a>. This means that the
time derivative is approximated by a centered
difference,</p>
<div class="math">
\[[D_t u = u(1-u)]^{n+\frac{1}{2}},\]</div>
<p>written out as</p>
<div class="math" id="eq-nonlin-timediscrete-logistic-geometric-mean-scheme">
\[\tag{6}
\frac{u^{n+1}-u^n}{\Delta t} = u^{n+\frac{1}{2}} -
    (u^{n+\frac{1}{2}})^2{\thinspace .}\]</div>
<p>The term <span class="math">\(u^{n+\frac{1}{2}}\)</span> is normally approximated by an arithmetic
mean,</p>
<div class="math">
\[u^{n+\frac{1}{2}}\approx \frac{1}{2}(u^n + u^{n+1}),\]</div>
<p>such that the scheme involves the unknown function only at the time levels
where we actually compute it.
The same arithmetic mean applied to the nonlinear term gives</p>
<div class="math">
\[(u^{n+\frac{1}{2}})^2\approx \frac{1}{4}(u^n + u^{n+1})^2,\]</div>
<p>which is nonlinear in the unknown <span class="math">\(u^{n+1}\)</span>.
However, using a <em>geometric mean</em> for <span class="math">\((u^{n+\frac{1}{2}})^2\)</span>
is a way of linearizing the nonlinear term in
<a class="reference internal" href="#eq-nonlin-timediscrete-logistic-geometric-mean-scheme"><span>(6)</span></a>:</p>
<div class="math">
\[(u^{n+\frac{1}{2}})^2\approx u^nu^{n+1}{\thinspace .}\]</div>
<p>Using an arithmetic mean on the linear <span class="math">\(u^{n+\frac{1}{2}}\)</span> term in
<a class="reference internal" href="#eq-nonlin-timediscrete-logistic-geometric-mean-scheme"><span>(6)</span></a> and a geometric
mean for the second term, results in a linearized equation for the
unknown <span class="math">\(u^{n+1}\)</span>:</p>
<div class="math">
\[\frac{u^{n+1}-u^n}{\Delta t} =
\frac{1}{2}(u^n + u^{n+1}) - u^nu^{n+1},\]</div>
<p>which can readily be solved:</p>
<div class="math">
\[u^{n+1} = \frac{1 + \frac{1}{2}\Delta t}{1+\Delta t u^n - \frac{1}{2}\Delta t}
u^n{\thinspace .}\]</div>
<p>This scheme can be coded directly, and since
there is no nonlinear algebraic equation to iterate over,
we skip the simplified notation with <span class="math">\(u\)</span> for <span class="math">\(u^{n+1}\)</span>
and <span class="math">\(u^{(1)}\)</span> for <span class="math">\(u^n\)</span>. The technique with using
a geometric average is an example of transforming a nonlinear
algebraic equation to a linear one, without any need for iterations.</p>
<p>The geometric mean approximation is often very effective for
linearizing quadratic nonlinearities. Both the arithmetic and geometric mean
approximations have truncation errors of order <span class="math">\(\Delta t^2\)</span> and are
therefore compatible with the truncation error <span class="math">\({\mathcal{O}(\Delta t^2)}\)</span>
of the centered difference approximation for <span class="math">\(u^\prime\)</span> in the Crank-Nicolson
method.</p>
<p>Applying the operator notation for the means and finite differences,
the linearized Crank-Nicolson scheme for the logistic equation can be
compactly expressed as</p>
<div class="math">
\[[D_t u = \overline{u}^{t} - \overline{u^2}^{t,g}]^{n+\frac{1}{2}}{\thinspace .}\]</div>
<div class="admonition-remark admonition">
<p class="first admonition-title">Remark</p>
<p class="last">If we use an arithmetic mean instead of a geometric mean
for the nonlinear term in
<a class="reference internal" href="#eq-nonlin-timediscrete-logistic-geometric-mean-scheme"><span>(6)</span></a>,
we end up with a nonlinear term <span class="math">\((u^{n+1})^2\)</span>.
This term can be linearized as <span class="math">\(u^{-}u^{n+1}\)</span> in a Picard iteration
approach and in particular as
<span class="math">\(u^nu^{n+1}\)</span> in a Picard1 iteration approach.
The latter gives a scheme almost identical to the one arising from
a geometric mean (the difference in <span class="math">\(u^{n+1}\)</span>
being <span class="math">\(\frac{1}{4}\Delta t u^n(u^{n+1}-u^n)\approx \frac{1}{4}\Delta t^2
u^\prime u\)</span>, i.e., a difference of <span class="math">\({\mathcal{O}(\Delta t^2)}\)</span>).</p>
</div>
</div>
<div class="section" id="newton-s-method-1">
<span id="nonlin-timediscrete-logistic-newton"></span><h2>Newton&#8217;s method<a class="headerlink" href="#newton-s-method-1" title="Permalink to this headline">¶</a></h2>
<p>The Backward Euler scheme <a class="reference internal" href="#eq-nonlin-timediscrete-logistic-eq-be"><span>(2)</span></a>
for the logistic equation leads to a nonlinear algebraic equation
<a class="reference internal" href="#eq-nonlin-timediscrete-logistic-eq-f"><span>(3)</span></a>. Now we write any nonlinear
algebraic equation in the general and compact form</p>
<div class="math">
\[F(u) = 0{\thinspace .}\]</div>
<p>Newton&#8217;s method linearizes this equation by approximating <span class="math">\(F(u)\)</span> with
its Taylor series expansion around a computed value <span class="math">\(u^{-}\)</span>
and keeping only the linear part:</p>
<div class="math">
\[\begin{split}F(u) &amp;= F(u^{-}) + F^{\prime}(u^{-})(u - u^{-}) + {\frac{1}{2}}F^{\prime\prime}(u^{-})(u-u^{-})^2
+\cdots\\
&amp; \approx F(u^{-}) + F^{\prime}(u^{-})(u - u^{-}) = \hat F(u){\thinspace .}\end{split}\]</div>
<p>The linear equation <span class="math">\(\hat F(u)=0\)</span> has the solution</p>
<div class="math">
\[u = u^{-} - \frac{F(u^{-})}{F^{\prime}(u^{-})}{\thinspace .}\]</div>
<p>Expressed with an iteration index in the unknown, Newton&#8217;s method takes
on the more familiar mathematical form</p>
<div class="math">
\[u^{k+1} = u^k - \frac{F(u^k)}{F^{\prime}(u^k)},\quad k=0,1,\ldots\]</div>
<p>It can be shown that the error in iteration <span class="math">\(k+1\)</span> of Newton&#8217;s method is
the square of the error in iteration <span class="math">\(k\)</span>, a result referred to as
<em>quadratic convergence</em>. This means that for
small errors the method converges very fast, and in particular much
faster than Picard iteration and other iteration methods.
(The proof of this result is found in most textbooks on numerical analysis.)
However, the quadratic convergence appears only if <span class="math">\(u^k\)</span> is sufficiently
close to the solution. Further away from the solution the method can
easily converge very slowly or diverge. The reader is encouraged to do
<a class="reference internal" href="._main_nonlin006.html#nonlin-exer-newton-problems1"><span>Problem 3: Experience the behavior of Newton&#8217;s method</span></a> to get a better understanding
for the behavior of the method.</p>
<p>Application of Newton&#8217;s method to the logistic equation discretized
by the Backward Euler method is straightforward
as we have</p>
<div class="math">
\[F(u) = au^2 + bu + c,\quad a=\Delta t,\ b = 1-\Delta t,\ c=-u^{(1)},\]</div>
<p>and then</p>
<div class="math">
\[F^{\prime}(u) = 2au + b{\thinspace .}\]</div>
<p>The iteration method becomes</p>
<div class="math" id="eq-nonlin-timediscrete-logistic-newton-alg1">
\[\tag{7}
u = u^{-} - \frac{a(u^{-})^2 + bu^{-} + c}{2au^{-} + b},\quad
    u^{-}\ \leftarrow u{\thinspace .}\]</div>
<p>At each time level, we start the iteration by setting <span class="math">\(u^{-}=u^{(1)}\)</span>.
Stopping criteria as listed for the Picard iteration can be used also
for Newton&#8217;s method.</p>
<p>An alternative mathematical form, where we write out <span class="math">\(a\)</span>, <span class="math">\(b\)</span>, and <span class="math">\(c\)</span>,
and use a time level counter <span class="math">\(n\)</span> and an iteration counter <span class="math">\(k\)</span>, takes
the form</p>
<div class="math" id="eq-nonlin-timediscrete-logistic-newton-alg2">
\[\tag{8}
u^{n,k+1} = u^{n,k} -
    \frac{\Delta t (u^{n,k})^2 + (1-\Delta t)u^{n,k} - u^{n-1}}
    {2\Delta t u^{n,k} + 1 - \Delta t},\quad u^{n,0}=u^{n-1},\quad k=0,1,\ldots\]</div>
<p>A program implementation is much closer to <a class="reference internal" href="#eq-nonlin-timediscrete-logistic-newton-alg1"><span>(7)</span></a> than to <a class="reference internal" href="#eq-nonlin-timediscrete-logistic-newton-alg2"><span>(8)</span></a>, but
the latter is better aligned with the established mathematical
notation used in the literature.</p>
</div>
<div class="section" id="relaxation">
<span id="nonlin-timediscrete-logistic-relaxation"></span><h2>Relaxation<a class="headerlink" href="#relaxation" title="Permalink to this headline">¶</a></h2>
<p id="index-10">One iteration in Newton&#8217;s method or
Picard iteration consists of solving a linear problem <span class="math">\(\hat F(u)=0\)</span>.
Sometimes convergence problems arise because the new solution <span class="math">\(u\)</span>
of <span class="math">\(\hat F(u)=0\)</span> is &#8220;too far away&#8221; from the previously computed
solution <span class="math">\(u^{-}\)</span>. A remedy is to introduce a relaxation, meaning that
we first solve <span class="math">\(\hat F(u^*)=0\)</span> for a suggested value <span class="math">\(u^*\)</span> and
then we take <span class="math">\(u\)</span> as a weighted mean of what we had, <span class="math">\(u^{-}\)</span>, and
what our linearized equation <span class="math">\(\hat F=0\)</span> suggests, <span class="math">\(u^*\)</span>:</p>
<div class="math">
\[u = \omega u^* + (1-\omega) u^{-}{\thinspace .}\]</div>
<p>The parameter <span class="math">\(\omega\)</span>
is known as a <em>relaxation parameter</em>, and a choice <span class="math">\(\omega &lt; 1\)</span>
may prevent divergent iterations.</p>
<p>Relaxation in Newton&#8217;s method can be directly incorporated
in the basic iteration formula:</p>
<div class="math" id="eq-nonlin-timediscrete-logistic-relaxation-newton-formula">
\[\tag{9}
u = u^{-} - \omega \frac{F(u^{-})}{F^{\prime}(u^{-})}{\thinspace .}\]</div>
</div>
<div class="section" id="implementation-and-experiments">
<span id="nonlin-timediscrete-logistic-impl"></span><h2>Implementation and experiments<a class="headerlink" href="#implementation-and-experiments" title="Permalink to this headline">¶</a></h2>
<p>The program <a class="reference external" href="http://tinyurl.com/nm5587k/nonlin/logistic.py">logistic.py</a> contains
implementations of all the methods described above.
Below is an extract of the file showing how the Picard and Newton
methods are implemented for a Backward Euler discretization of
the logistic equation.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">BE_logistic</span><span class="p">(</span><span class="n">u0</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">Nt</span><span class="p">,</span> <span class="n">choice</span><span class="o">=</span><span class="s">&#39;Picard&#39;</span><span class="p">,</span>
                <span class="n">eps_r</span><span class="o">=</span><span class="mf">1E-3</span><span class="p">,</span> <span class="n">omega</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">max_iter</span><span class="o">=</span><span class="mi">1000</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">choice</span> <span class="o">==</span> <span class="s">&#39;Picard1&#39;</span><span class="p">:</span>
        <span class="n">choice</span> <span class="o">=</span> <span class="s">&#39;Picard&#39;</span>
        <span class="n">max_iter</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="n">u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">iterations</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">u0</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">dt</span>
        <span class="n">b</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">dt</span>
        <span class="n">c</span> <span class="o">=</span> <span class="o">-</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">choice</span> <span class="o">==</span> <span class="s">&#39;Picard&#39;</span><span class="p">:</span>

            <span class="k">def</span> <span class="nf">F</span><span class="p">(</span><span class="n">u</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">a</span><span class="o">*</span><span class="n">u</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">b</span><span class="o">*</span><span class="n">u</span> <span class="o">+</span> <span class="n">c</span>

            <span class="n">u_</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">while</span> <span class="nb">abs</span><span class="p">(</span><span class="n">F</span><span class="p">(</span><span class="n">u_</span><span class="p">))</span> <span class="o">&gt;</span> <span class="n">eps_r</span> <span class="ow">and</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">max_iter</span><span class="p">:</span>
                <span class="n">u_</span> <span class="o">=</span> <span class="n">omega</span><span class="o">*</span><span class="p">(</span><span class="o">-</span><span class="n">c</span><span class="o">/</span><span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">u_</span> <span class="o">+</span> <span class="n">b</span><span class="p">))</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">omega</span><span class="p">)</span><span class="o">*</span><span class="n">u_</span>
                <span class="n">k</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">u_</span>
            <span class="n">iterations</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">choice</span> <span class="o">==</span> <span class="s">&#39;Newton&#39;</span><span class="p">:</span>

            <span class="k">def</span> <span class="nf">F</span><span class="p">(</span><span class="n">u</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">a</span><span class="o">*</span><span class="n">u</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">b</span><span class="o">*</span><span class="n">u</span> <span class="o">+</span> <span class="n">c</span>

            <span class="k">def</span> <span class="nf">dF</span><span class="p">(</span><span class="n">u</span><span class="p">):</span>
                <span class="k">return</span> <span class="mi">2</span><span class="o">*</span><span class="n">a</span><span class="o">*</span><span class="n">u</span> <span class="o">+</span> <span class="n">b</span>

            <span class="n">u_</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">while</span> <span class="nb">abs</span><span class="p">(</span><span class="n">F</span><span class="p">(</span><span class="n">u_</span><span class="p">))</span> <span class="o">&gt;</span> <span class="n">eps_r</span> <span class="ow">and</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">max_iter</span><span class="p">:</span>
                <span class="n">u_</span> <span class="o">=</span> <span class="n">u_</span> <span class="o">-</span> <span class="n">omega</span><span class="o">*</span><span class="n">F</span><span class="p">(</span><span class="n">u_</span><span class="p">)</span><span class="o">/</span><span class="n">dF</span><span class="p">(</span><span class="n">u_</span><span class="p">)</span>
                <span class="n">k</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">u_</span>
            <span class="n">iterations</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">u</span><span class="p">,</span> <span class="n">iterations</span>
</pre></div>
</div>
<p>The Crank-Nicolson method utilizing a linearization based on the
geometric mean gives a simpler algorithm:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">CN_logistic</span><span class="p">(</span><span class="n">u0</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">Nt</span><span class="p">):</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">u0</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Nt</span><span class="p">):</span>
        <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">dt</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">dt</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">-</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">dt</span><span class="p">)</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">u</span>
</pre></div>
</div>
<p>We may run experiments with the model problem
<a class="reference internal" href="#eq-nonlin-timediscrete-logistic-eq"><span>(1)</span></a> and the different strategies for
dealing with nonlinearities as described above. For a quite coarse
time resolution, <span class="math">\(\Delta t=0.9\)</span>, use of a tolerance <span class="math">\(\epsilon_r=0.1\)</span>
in the stopping criterion introduces an iteration error, especially in
the Picard iterations, that is visibly much larger than the
time discretization error due to a large <span class="math">\(\Delta t\)</span>. This is illustrated
by comparing the upper two plots in
Figure <a class="reference internal" href="#nonlin-timediscrete-logistic-impl-fig-u"><span>Impact of solution strategy and time step length on the solution</span></a>. The one to
the right has a stricter tolerance <span class="math">\(\epsilon = 10^{-3}\)</span>, which leads
to all the curves corresponding to Picard and Newton iteration to be
on top of each other (and no changes can be visually observed by
reducing <span class="math">\(\epsilon_r\)</span> further). The reason why Newton&#8217;s method does
much better than Picard iteration in the upper left plot is that
Newton&#8217;s method with one step comes far below the <span class="math">\(\epsilon_r\)</span> tolerance,
while the Picard iteration needs on average 7 iterations to bring the
residual down to <span class="math">\(\epsilon_r=10^{-1}\)</span>, which gives insufficient
accuracy in the solution of the nonlinear equation. It is obvious
that the Picard1 method gives significant errors in addition to
the time discretization unless the time step is as small as in
the lower right plot.</p>
<p>The <em>BE exact</em> curve corresponds to using the exact solution of the
quadratic equation at each time level, so this curve is only affected
by the Backward Euler time discretization.  The <em>CN gm</em> curve
corresponds to the theoretically more accurate Crank-Nicolson
discretization, combined with a geometric mean for linearization.
This curve appears as more accurate, especially if we take the plot in
the lower right with a small <span class="math">\(\Delta t\)</span> and an appropriately small
<span class="math">\(\epsilon_r\)</span> value as the exact curve.</p>
<p>When it comes to the need for iterations, Figure
<a class="reference internal" href="#nonlin-timediscrete-logistic-impl-fig-iter"><span>Comparison of the number of iterations at various time levels for Picard and Newton iteration</span></a> displays the number of
iterations required at each time level for Newton&#8217;s method and
Picard iteration. The smaller <span class="math">\(\Delta t\)</span> is, the better starting value
we have for the iteration, and the faster the convergence is.
With <span class="math">\(\Delta t = 0.9\)</span> Picard iteration requires on average 32 iterations
per time step, but this number is dramatically reduced as <span class="math">\(\Delta t\)</span>
is reduced.</p>
<p>However, introducing relaxation and a parameter <span class="math">\(\omega=0.8\)</span>
immediately reduces the average of 32 to 7, indicating that for the large
<span class="math">\(\Delta t=0.9\)</span>, Picard iteration takes too long steps. An approximately optimal
value for <span class="math">\(\omega\)</span> in this case is 0.5, which results in an average of only
2 iterations! Even more dramatic impact of <span class="math">\(\omega\)</span> appears when
<span class="math">\(\Delta t = 1\)</span>: Picard iteration does not convergence in 1000 iterations,
but <span class="math">\(\omega=0.5\)</span> again brings the average number of iterations down to 2.</p>
<div class="figure" id="id1">
<span id="nonlin-timediscrete-logistic-impl-fig-u"></span><a class="reference internal image-reference" href="_images/logistic_u.png"><img alt="_images/logistic_u.png" src="_images/logistic_u.png" style="width: 800px;" /></a>
<p class="caption"><span class="caption-text"><em>Impact of solution strategy and time step length on the solution</em></span></p>
</div>
<div class="figure" id="id2">
<span id="nonlin-timediscrete-logistic-impl-fig-iter"></span><a class="reference internal image-reference" href="_images/logistic_iter.png"><img alt="_images/logistic_iter.png" src="_images/logistic_iter.png" style="width: 800px;" /></a>
<p class="caption"><span class="caption-text"><em>Comparison of the number of iterations at various time levels for Picard and Newton iteration</em></span></p>
</div>
<p><strong>Remark.</strong>
The simple Crank-Nicolson method with a geometric mean for the quadratic
nonlinearity gives visually more accurate solutions than the
Backward Euler discretization. Even with a tolerance of <span class="math">\(\epsilon_r=10^{-3}\)</span>,
all the methods for treating the nonlinearities in the Backward Euler
discretization give graphs that cannot be distinguished. So for
accuracy in this problem, the time discretization is much more crucial
than <span class="math">\(\epsilon_r\)</span>. Ideally, one should estimate the error in the
time discretization, as the solution progresses, and set <span class="math">\(\epsilon_r\)</span>
accordingly.</p>
</div>
<div class="section" id="generalization-to-a-general-nonlinear-ode">
<span id="nonlin-ode-generic"></span><h2>Generalization to a general nonlinear ODE<a class="headerlink" href="#generalization-to-a-general-nonlinear-ode" title="Permalink to this headline">¶</a></h2>
<p>Let us see how the various methods in the previous sections
can be applied to the more generic model</p>
<div class="math" id="eq-nonlin-ode-generic-model">
\[\tag{10}
u^{\prime} = f(u, t),\]</div>
<p>where <span class="math">\(f\)</span> is a nonlinear function of <span class="math">\(u\)</span>.</p>
<div class="section" id="explicit-time-discretization">
<h3>Explicit time discretization<a class="headerlink" href="#explicit-time-discretization" title="Permalink to this headline">¶</a></h3>
<p>Explicit ODE methods like the Forward Euler scheme, Runge-Kutta methods,
Adams-Bashforth methods all evaluate <span class="math">\(f\)</span> at time levels where
<span class="math">\(u\)</span> is already computed, so nonlinearities in <span class="math">\(f\)</span> do not
pose any difficulties.</p>
</div>
<div class="section" id="backward-euler-discretization">
<h3>Backward Euler discretization<a class="headerlink" href="#backward-euler-discretization" title="Permalink to this headline">¶</a></h3>
<p>Approximating <span class="math">\(u^{\prime}\)</span> by a backward difference leads to a Backward Euler
scheme, which can be written as</p>
<div class="math">
\[F(u^n) = u^{n} - \Delta t\, f(u^n, t_n) - u^{n-1}=0,\]</div>
<p>or alternatively</p>
<div class="math">
\[F(u) = u - \Delta t\, f(u, t_n) - u^{(1)} = 0{\thinspace .}\]</div>
<p>A simple Picard iteration, not knowing anything about the nonlinear
structure of <span class="math">\(f\)</span>, must approximate <span class="math">\(f(u,t_n)\)</span> by <span class="math">\(f(u^{-},t_n)\)</span>:</p>
<div class="math">
\[\hat F(u) = u - \Delta t\, f(u^{-},t_n) - u^{(1)}{\thinspace .}\]</div>
<p>The iteration starts with <span class="math">\(u^{-}=u^{(1)}\)</span> and proceeds with repeating</p>
<div class="math">
\[u^* = \Delta t\, f(u^{-},t_n) + u^{(1)},\quad u = \omega u^* + (1-\omega)u^{-},
\quad u^{-}\ \leftarrow\ u,\]</div>
<p>until a stopping criterion is fulfilled.</p>
<div class="admonition-explicit-vs-implicit-treatment-of-nonlinear-terms admonition">
<p class="first admonition-title">Explicit vs implicit treatment of nonlinear terms</p>
<p>Evaluating <span class="math">\(f\)</span> for a known <span class="math">\(u^{-}\)</span> is referred to as <em>explicit</em> treatment of
<span class="math">\(f\)</span>, while if <span class="math">\(f(u,t)\)</span> has some structure, say <span class="math">\(f(u,t) = u^3\)</span>, parts of
<span class="math">\(f\)</span> can involve the known <span class="math">\(u\)</span>, as in the manual linearization
like <span class="math">\((u^{-})^2u\)</span>, and then the treatment of <span class="math">\(f\)</span> is &#8220;more implicit&#8221;
and &#8220;less explicit&#8221;. This terminology is inspired by time discretization
of <span class="math">\(u^{\prime}=f(u,t)\)</span>, where evaluating <span class="math">\(f\)</span> for known <span class="math">\(u\)</span> values gives
explicit schemes, while treating <span class="math">\(f\)</span> or parts of <span class="math">\(f\)</span> implicitly,
makes <span class="math">\(f\)</span> contribute to the unknown terms in the equation at the new
time level.</p>
<p>Explicit treatment of <span class="math">\(f\)</span> usually means stricter conditions on
<span class="math">\(\Delta t\)</span> to achieve stability of time discretization schemes. The same
applies to iteration techniques for nonlinear algebraic equations: the &#8220;less&#8221;
we linearize <span class="math">\(f\)</span> (i.e., the more we keep of <span class="math">\(u\)</span> in the original formula),
the faster the convergence may be.</p>
<p>We may say that <span class="math">\(f(u,t)=u^3\)</span> is treated explicitly if we evaluate <span class="math">\(f\)</span>
as <span class="math">\((u^{-})^3\)</span>, partially implicit if we linearize as <span class="math">\((u^{-})^2u\)</span>
and fully implicit if we represent <span class="math">\(f\)</span> by <span class="math">\(u^3\)</span>. (Of course, the
fully implicit representation will require further linearization,
but with <span class="math">\(f(u,t)=u^2\)</span> a fully implicit treatment is possible if
the resulting quadratic equation is solved with a formula.)</p>
<p>For the ODE <span class="math">\(u^{\prime}=-u^3\)</span> with <span class="math">\(f(u,t)=-u^3\)</span> and coarse
time resolution <span class="math">\(\Delta t = 0.4\)</span>, Picard iteration with <span class="math">\((u^{-})^2u\)</span>
requires 8 iterations with <span class="math">\(\epsilon_r = 10^{-3}\)</span> for the first
time step, while <span class="math">\((u^{-})^3\)</span> leads to 22 iterations. After about 10
time steps both approaches are down to about 2 iterations per time
step, but this example shows a potential of treating <span class="math">\(f\)</span> more
implicitly.</p>
<p class="last">A trick to treat <span class="math">\(f\)</span> implicitly in Picard iteration is to
evaluate it as <span class="math">\(f(u^{-},t)u/u^{-}\)</span>. For a polynomial <span class="math">\(f\)</span>, <span class="math">\(f(u,t)=u^m\)</span>,
this corresponds to <span class="math">\((u^{-})^{m-1}u\)</span>. Sometimes this more implicit
treatment has no effect, as with <span class="math">\(f(u,t)=\exp(-u)\)</span> and <span class="math">\(f(u,t)=\ln (1+u)\)</span>,
but with <span class="math">\(f(u,t)=\sin(2(u+1))\)</span>, the <span class="math">\(f(u^{-},t)u/u^{-}\)</span> trick
leads to 7, 9, and 11 iterations during the first three steps, while
<span class="math">\(f(u^{-},t)\)</span> demands 17, 21, and 20 iterations.
(Experiments can be done with the code <a class="reference external" href="http://tinyurl.com/nm5587k/nonlin/ODE_Picard_tricks.py">ODE_Picard_tricks.py</a>.)</p>
</div>
<p>Newton&#8217;s method applied to a Backward Euler discretization of
<span class="math">\(u^{\prime}=f(u,t)\)</span>
requires the computation of the derivative</p>
<div class="math">
\[F^{\prime}(u) = 1 - \Delta t\frac{\partial f}{\partial u}(u,t_n){\thinspace .}\]</div>
<p>Starting with the solution at the previous time level, <span class="math">\(u^{-}=u^{(1)}\)</span>,
we can just use the standard formula</p>
<div class="math" id="eq-nonlin-ode-generic-newton">
\[\tag{11}
u = u^{-} - \omega \frac{F(u^{-})}{F^{\prime}(u^{-})}
    = u^{-} - \omega \frac{u^{-} - \Delta t\, f(u^{-}, t_n) - u^{(1)}}{1 - \Delta t
    \frac{\partial}{\partial u}f(u^{-},t_n)}
    {\thinspace .}\]</div>
</div>
<div class="section" id="crank-nicolson-discretization-1">
<h3>Crank-Nicolson discretization<a class="headerlink" href="#crank-nicolson-discretization-1" title="Permalink to this headline">¶</a></h3>
<p>The standard Crank-Nicolson scheme with arithmetic mean approximation of
<span class="math">\(f\)</span> takes the form</p>
<div class="math">
\[\frac{u^{n+1} - u^n}{\Delta t} = \frac{1}{2}(f(u^{n+1}, t_{n+1})
+ f(u^n, t_n)){\thinspace .}\]</div>
<p>We can write the scheme as a nonlinear algebraic equation</p>
<div class="math" id="eq-nonlin-ode-generic-newton2">
\[\tag{12}
F(u) = u - u^{(1)} - \Delta t{\frac{1}{2}}f(u,t_{n+1}) -
    \Delta t{\frac{1}{2}}f(u^{(1)},t_{n}) = 0{\thinspace .}\]</div>
<p>A Picard iteration scheme must in general employ the linearization</p>
<div class="math">
\[\hat F(u) = u - u^{(1)} - \Delta t{\frac{1}{2}}f(u^{-},t_{n+1}) -
\Delta t{\frac{1}{2}}f(u^{(1)},t_{n}),\]</div>
<p>while Newton&#8217;s method can apply the general formula
<a class="reference internal" href="#eq-nonlin-ode-generic-newton"><span>(11)</span></a> with <span class="math">\(F(u)\)</span> given in
<a class="reference internal" href="#eq-nonlin-ode-generic-newton2"><span>(12)</span></a> and</p>
<div class="math">
\[F^{\prime}(u)= 1 - \frac{1}{2}\Delta t\frac{\partial f}{\partial u}(u,t_{n+1}){\thinspace .}\]</div>
</div>
</div>
<div class="section" id="systems-of-odes">
<span id="nonlin-ode-generic-sys-pendulum"></span><h2>Systems of ODEs<a class="headerlink" href="#systems-of-odes" title="Permalink to this headline">¶</a></h2>
<p>We may write a system of ODEs</p>
<div class="math">
\[\begin{split}\frac{d}{dt}u_0(t) &amp;= f_0(u_0(t),u_1(t),\ldots,u_N(t),t),\\
\frac{d}{dt}u_1(t) &amp;= f_1(u_0(t),u_1(t),\ldots,u_N(t),t),\\
&amp;\vdots\\
\frac{d}{dt}u_N(t) &amp;= f_N(u_0(t),u_1(t),\ldots,u_N(t),t),\end{split}\]</div>
<p>as</p>
<div class="math" id="eq-auto1">
\[\tag{13}
u^{\prime} = f(u,t),\quad u(0)=U_0,\]</div>
<p>if we interpret <span class="math">\(u\)</span> as a vector <span class="math">\(u=(u_0(t),u_1(t),\ldots,u_N(t))\)</span>
and <span class="math">\(f\)</span> as a vector function with components
<span class="math">\((f_0(u,t),f_1(u,t),\ldots,f_N(u,t))\)</span>.</p>
<p>Most solution methods for scalar ODEs, including
the Forward and Backward Euler schemes and the
Crank-Nicolson method, generalize in a
straightforward way to systems of ODEs simply by using vector
arithmetics instead of scalar arithmetics, which corresponds to
applying the scalar scheme to each component of the system.  For
example, here is a backward difference scheme applied to each
component,</p>
<div class="math">
\[\begin{split}\frac{u_0^n- u_0^{n-1}}{\Delta t} &amp;= f_0(u^n,t_n),\\
\frac{u_1^n- u_1^{n-1}}{\Delta t} &amp;= f_1(u^n,t_n),\\
&amp;\vdots\\
\frac{u_N^n- u_N^{n-1}}{\Delta t} &amp;= f_N(u^n,t_n),\end{split}\]</div>
<p>which can be written more compactly in vector form as</p>
<div class="math">
\[\frac{u^n- u^{n-1}}{\Delta t} = f(u^n,t_n){\thinspace .}\]</div>
<p>This is a <em>system of algebraic equations</em>,</p>
<div class="math">
\[u^n - \Delta t\,f(u^n,t_n) - u^{n-1}=0,\]</div>
<p>or written out</p>
<div class="math">
\[\begin{split}u_0^n - \Delta t\, f_0(u^n,t_n) - u_0^{n-1} &amp;= 0,\\
&amp;\vdots\\
u_N^n - \Delta t\, f_N(u^n,t_n) - u_N^{n-1} &amp;= 0{\thinspace .}\end{split}\]</div>
<div class="section" id="example">
<h3>Example<a class="headerlink" href="#example" title="Permalink to this headline">¶</a></h3>
<p>We shall address the <span class="math">\(2\times 2\)</span> ODE system for
oscillations of a pendulum
subject to gravity and air drag. The system can be written as</p>
<div class="math" id="eq-auto2">
\[\tag{14}
\dot\omega = -\sin\theta -\beta \omega |\omega|,\]</div>
<div class="math" id="eq-auto3">
\[\tag{15}
\dot\theta = \omega,\]</div>
<p>where <span class="math">\(\beta\)</span> is a dimensionless parameter (this is the scaled, dimensionless
version of the original, physical model). The unknown components of the
system are the
angle <span class="math">\(\theta(t)\)</span> and the angular velocity <span class="math">\(\omega(t)\)</span>.
We introduce <span class="math">\(u_0=\omega\)</span> and <span class="math">\(u_1=\theta\)</span>, which leads to</p>
<div class="math">
\[\begin{split}u_0^{\prime} = f_0(u,t) &amp;= -\sin u_1 - \beta u_0|u_0|,\\
u_1^{\prime} = f_1(u,t) &amp;= u_0{\thinspace .}\end{split}\]</div>
<p>A Crank-Nicolson scheme reads</p>
<div class="math">
\[\frac{u_0^{n+1}-u_0^{n}}{\Delta t} = -\sin u_1^{n+\frac{1}{2}}
- \beta u_0^{n+\frac{1}{2}}|u_0^{n+\frac{1}{2}}|\nonumber\]</div>
<div class="math" id="eq-auto4">
\[\tag{16}
\approx -\sin\left(\frac{1}{2}(u_1^{n+1} + u_1^n)\right)
    - \beta\frac{1}{4} (u_0^{n+1} + u_0^n)|u_0^{n+1}+u_0^n|,\]</div>
<div class="math" id="eq-auto5">
\[\tag{17}
\frac{u_1^{n+1}-u_1^n}{\Delta t} = u_0^{n+\frac{1}{2}}\approx
    \frac{1}{2} (u_0^{n+1}+u_0^n){\thinspace .}\]</div>
<p>This is a <em>coupled system</em> of two nonlinear algebraic equations
in two unknowns <span class="math">\(u_0^{n+1}\)</span> and <span class="math">\(u_1^{n+1}\)</span>.</p>
<p>Using the notation <span class="math">\(u_0\)</span> and <span class="math">\(u_1\)</span> for the unknowns <span class="math">\(u_0^{n+1}\)</span> and
<span class="math">\(u_1^{n+1}\)</span> in this system, writing <span class="math">\(u_0^{(1)}\)</span> and
<span class="math">\(u_1^{(1)}\)</span> for the previous values <span class="math">\(u_0^n\)</span> and <span class="math">\(u_1^n\)</span>, multiplying
by <span class="math">\(\Delta t\)</span> and moving the terms to the left-hand sides, gives</p>
<div class="math" id="eq-nonlin-ode-generic-sys-pendulum-u0">
\[\tag{18}
u_0 - u_0^{(1)} + \Delta t\,\sin\left(\frac{1}{2}(u_1 + u_1^{(1)})\right)
    + \frac{1}{4}\Delta t\beta (u_0 + u_0^{(1)})|u_0 + u_0^{(1)}| =0,\]</div>
<div class="math" id="eq-nonlin-ode-generic-sys-pendulum-u1">
\[\tag{19}
u_1 - u_1^{(1)} -\frac{1}{2}\Delta t(u_0 + u_0^{(1)}) =0{\thinspace .}\]</div>
<p>Obviously, we have a need for solving systems of nonlinear algebraic
equations, which is the topic of the next section.</p>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <center>
            <p class="logo"><a href="http://cbc.simula.no/" title="Go to Center for Biomedical Computing">
              <img class="logo" src="_static/cbc_logo.png" alt="Logo"/>
            </a></p>
            </center>
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Introduction of basic concepts</a><ul>
<li><a class="reference internal" href="#linear-versus-nonlinear-equations">Linear versus nonlinear equations</a><ul>
<li><a class="reference internal" href="#algebraic-equations">Algebraic equations</a></li>
<li><a class="reference internal" href="#differential-equations">Differential equations</a></li>
</ul>
</li>
<li><a class="reference internal" href="#a-simple-model-problem">A simple model problem</a></li>
<li><a class="reference internal" href="#linearization-by-explicit-time-discretization">Linearization by explicit time discretization</a></li>
<li><a class="reference internal" href="#exact-solution-of-nonlinear-algebraic-equations">Exact solution of nonlinear algebraic equations</a></li>
<li><a class="reference internal" href="#linearization">Linearization</a></li>
<li><a class="reference internal" href="#picard-iteration-1">Picard iteration</a><ul>
<li><a class="reference internal" href="#stopping-criteria-1">Stopping criteria</a></li>
<li><a class="reference internal" href="#a-single-picard-iteration">A single Picard iteration</a></li>
</ul>
</li>
<li><a class="reference internal" href="#linearization-by-a-geometric-mean">Linearization by a geometric mean</a></li>
<li><a class="reference internal" href="#newton-s-method-1">Newton&#8217;s method</a></li>
<li><a class="reference internal" href="#relaxation">Relaxation</a></li>
<li><a class="reference internal" href="#implementation-and-experiments">Implementation and experiments</a></li>
<li><a class="reference internal" href="#generalization-to-a-general-nonlinear-ode">Generalization to a general nonlinear ODE</a><ul>
<li><a class="reference internal" href="#explicit-time-discretization">Explicit time discretization</a></li>
<li><a class="reference internal" href="#backward-euler-discretization">Backward Euler discretization</a></li>
<li><a class="reference internal" href="#crank-nicolson-discretization-1">Crank-Nicolson discretization</a></li>
</ul>
</li>
<li><a class="reference internal" href="#systems-of-odes">Systems of ODEs</a><ul>
<li><a class="reference internal" href="#example">Example</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="._main_nonlin000.html"
                        title="previous chapter">Solving nonlinear ODE and PDE problems</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="._main_nonlin002.html"
                        title="next chapter">Systems of nonlinear algebraic equations</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/._main_nonlin001.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="._main_nonlin002.html" title="Systems of nonlinear algebraic equations"
             >next</a> |</li>
        <li class="right" >
          <a href="._main_nonlin000.html" title="Solving nonlinear ODE and PDE problems"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Solving nonlinear ODE and PDE problems</a> &raquo;</li> 
      </ul>
    </div>
<div class="wrapper">
  <div class="footer">
    <a href="http://cbc.simula.no"><img src="_static/cbc_banner.png" width="100%"><a>
    <br />
    <br />
      &copy;2019, Hans Petter Langtangen.
  </div>
</div>

  </body>
</html>
